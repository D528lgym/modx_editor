/***************************************************************************
 *   Copyright (C) 2009 by the phpBB Group                                 *
 *   phpbb.com                                                             *
 *                                                                         *
 *  This file is part of MODX Editor.                                      *
 *                                                                         *
 *  MODX Editor is free software: you can redistribute it and/or modify    *
 *  it under the terms of the GNU General Public License as published by   *
 *  the Free Software Foundation, either version 3 of the License, or      *
 *  (at your option) any later version.                                    *
 *                                                                         *
 *  MODX Editor is distributed in the hope that it will be useful,         *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *  GNU General Public License for more details.                           *
 *                                                                         *
 *  You should have received a copy of the GNU General Public License      *
 *  along with MODX Editor.  If not, see <http://www.gnu.org/licenses/>.   *
 ***************************************************************************/

#include "modxwriter.h"

#include "modxdata.h"

#include <QMap>
#include <QStringList>
#include <QCoreApplication>

ModXWriter::ModXWriter()
{
	setAutoFormatting(true);
}

void ModXWriter::setData(const ModXData *data)
{
	m_data = data;
}


void ModXWriter::write(QIODevice *device)
{
	if (m_data == NULL)
		return;

	setDevice(device);

	writeProcessingInstruction("xml", "version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"");\
	writeProcessingInstruction("xml-stylesheet", "type=\"text/xsl\" href=\"modx.prosilver.en.xsl\"");
	writeComment(
			"For security purposes, please check: "
			"http://www.phpbb.com/mods/ for the latest version of this MOD. "
			"Although MODs are checked before being allowed in the MODs Database "
			"there is no guarantee that there are no security problems within the MOD. "
			"No support will be given for MODs not found within the MODs Database "
			"which can be found at http://www.phpbb.com/mods/");
	writeStartElement("mod");
	writeAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
	writeAttribute("xmlns", "http://www.phpbb.com/mods/xml/modx-1.2.1.xsd");

	writeHeader();
	writeActionGroup();
	writeEndDocument();
}

void ModXWriter::writeHeader()
{
	writeStartElement("header");

	for (QMap<QString, QString>::ConstIterator i = m_data->title.constBegin(); i != m_data->title.constEnd(); ++i)
	{
		writeStartElement("title");
		writeAttribute("lang", i.key());
		writeCharacters(i.value());
		writeEndElement();
	}

	for (QMap<QString, QString>::ConstIterator i = m_data->description.constBegin(); i != m_data->description.constEnd(); ++i)
	{
		writeStartElement("description");
		writeAttribute("lang", i.key());
		writeCharacters(i.value());
		writeEndElement();
	}

	for (QMap<QString, QString>::ConstIterator i = m_data->authorNotes.constBegin(); i != m_data->authorNotes.constEnd(); ++i)
	{
		writeStartElement("author-notes");
		writeAttribute("lang", i.key());
		writeCharacters(i.value());
		writeEndElement();
	}

		writeAuthorGroup();

		writeStartElement("mod-version");
			writeCharacters(m_data->version);
		writeEndElement();

		writeStartElement("installation");
			writeStartElement("level");
				writeCharacters(ModXData::installationLevels.at(int(m_data->installLevel)));
			writeEndElement();
			writeStartElement("time");
				writeCharacters(QString::number(m_data->installTime));
			writeEndElement();
			writeStartElement("target-version");
				writeCharacters(m_data->targetVersion);
			writeEndElement();
		writeEndElement();

		writeHistory();

		writeStartElement("meta");
			writeCharacters("Generated by " + QCoreApplication::applicationName() + " v" + QCoreApplication::applicationVersion());
		writeEndElement();

		writeStartElement("license");
				writeCharacters(m_data->license);
		writeEndElement();
	writeEndElement();
}

void ModXWriter::writeAuthorGroup()
{
	writeStartElement("author-group");
	foreach (Author author, m_data->authorGroup)
	{
		writeStartElement("author");
			writeStartElement("realname");
				writeCharacters(author.realName);
			writeEndElement();
			writeStartElement("username");
				writeCharacters(author.userName);
			writeEndElement();
			writeStartElement("email");
				writeCharacters(author.email);
			writeEndElement();
			writeStartElement("homepage");
				writeCharacters(author.homePage);
			writeEndElement();
			writeStartElement("contributions");
				writeAttribute("status", author.contributionStatus);
				writeAttribute("from", author.contributionFrom.toString(Qt::ISODate));
				writeAttribute("to", author.contributionTo.toString(Qt::ISODate));
			writeEndElement();
		writeEndElement();
	}
	writeEndElement();
}

void ModXWriter::writeHistory()
{
	writeStartElement("history");

	foreach (ChangelogEntry entry, m_data->history)
	{
		writeStartElement("entry");
			writeStartElement("date");
				writeCharacters(entry.date.toString(Qt::ISODate));
			writeEndElement();
			writeStartElement("rev-version");
				writeCharacters(entry.version);
			writeEndElement();
			for (QMap<QString, QStringList>::ConstIterator i = entry.changes.constBegin(); i != entry.changes.constEnd(); ++i)
			{
				writeStartElement("changelog");
				writeAttribute("lang", i.key());
				foreach (QString change, i.value())
				{
					writeStartElement("change");
						writeCharacters(change);
					writeEndElement();
				}
				writeEndElement();
			}
		writeEndElement();
	}
	writeEndElement();
}

void ModXWriter::writeActionGroup()
{
	writeStartElement("action-group");

	foreach(QString sql, m_data->sql)
	{
		writeStartElement("sql");
			writeAttribute("dbms", ModXData::sqlDialects[m_data->sqlDialect]);
			writeCharacters(sql);
		writeEndElement();
	}

	if (m_data->copyFiles)
	{
		writeStartElement("copy");
			writeComment("A_Jelly_Donut said this is enough to copy all files from root/ recursively.\n\tEspecially the to=\"*.*\" part!");
			writeStartElement("file");
				writeAttribute("from", "root/*.*");
				writeAttribute("to", "*.*");
			writeEndElement();
		writeEndElement();
	}

	writeOpen();

	for (QMap<QString, QString>::ConstIterator i = m_data->diy.constBegin(); i != m_data->diy.constEnd(); ++i)
	{
		writeStartElement("diy-instructions");
			writeAttribute("lang", i.key());
			writeCharacters(i.value());
		writeEndElement();
	}
	writeEndElement();
}

void ModXWriter::writeOpen()
{
	for (QMap<QString, QList<Action> >::const_iterator i = m_data->actions.constBegin(); i != m_data->actions.constEnd(); ++i)
	{
		Action::Type prevActionType = Action::Find;
		writeStartElement("open");
			writeAttribute("src", i.key());

			writeStartElement("edit");
			foreach (Action action, i.value())
			{
				switch (action.type)
				{
					case Action::Find:
						if (prevActionType == Action::InlineFind || prevActionType == Action::InlineEdit)
						{
							writeEndElement();
						}
						if (prevActionType != Action::Find)
						{
							writeEndElement();
							writeStartElement("edit");
						}
						writeStartElement("find");
							writeCharacters(action.find);
						writeEndElement();
					break;
					case Action::Edit:
						if (prevActionType == Action::InlineFind || prevActionType == Action::InlineEdit)
						{
							writeEndElement();
						}
						writeStartElement("action");
							writeAttribute("type", Action::editTypes[action.editType]);
							writeCharacters(action.edit);
						writeEndElement();
					break;
					case Action::InlineFind:
						if (prevActionType != Action::InlineFind && prevActionType != Action::InlineEdit)
						{
							writeStartElement("inline-edit");
						}
						writeStartElement("inline-find");
							writeCharacters(action.find);
						writeEndElement();
					break;
					case Action::InlineEdit:
						if (prevActionType != Action::InlineFind && prevActionType != Action::InlineEdit)
						{
							writeStartElement("inline-edit");
						}
						writeStartElement("inline-action");
							writeAttribute("type", Action::editTypes[action.editType]);
							writeCharacters(action.edit);
						writeEndElement();
					break;
				}
				prevActionType = action.type;
			}
			if (prevActionType == Action::InlineFind || prevActionType == Action::InlineEdit)
			{
				writeEndElement();
			}
			writeEndElement();
		writeEndElement();
	}
}
